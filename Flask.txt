Task 001 - მოდულები და ბიბლიოთეკების დანიშნულება:

    flask-ის მოდულები: 
        Flask  -   აპის ობიექტის შესაქმნელად.
        render_template - HTML ფაილების ჩასატვირთად, დასაკავშირებლად.
        request  -  ფორმის მონაცემების მისაღებად (POST/GET).
        session  - მომხმარებლის ინფორმაციის შესანახად სახელი, კოდი და ა.შ.
        redirect  - გამოიყენება სხვადასხვა გვერდზე გადასამისამართებლად.
        url_for - კონკრეტული ფუნქციის URL-მისამართის დასადგენად.
        jsonify - JSON მონაცემების გასაგზავნად.


    EmailMessage - email მოდული, რომელიც გამოიყენება მეილსების შექმნისთვის და გამოგზავნისთვის.
    random  - რენდომი.
    SSL - იშიფრება როგორც Secure Sockets Layer და რომელიც უზრუნველყოფს ინტერნეტში ინფორმაციის დაშიფვრას-გაგზავნას, რომ ზუსტი და უსაფრთხო კომუნიკაცია იყოს მომხმარებელსა და სერვერს შორის.
    განსაკუთრებით მნიშვნელოვანია, როცა იგზავნება ძალიან მნოშვნელოვანი ინფორმაცია. პაროლები, პირადი მონაცემები, ელ-ფოსტა და ა.შ.
    smtplib - გამოიყენება ელექტრონული ფოსტის (email) გაგზავნისთვის SMTP პროტოკოლით. SMTP — Simple Mail Transfer Protocol, ანუ მარტივი იმეილის გადაცემა.
    os - იშიფრება როგორც Operating System - ოპერაციული სისტემის ფუნქციებს აღწევს — მაგალითად, ფაილებისა და დირექტორიების მართვა, გარემოს ცვლადებთან მუშაობა, პროცედურების გაშვებაც შეუძლია.
    json მოდული საშუალებას გვაძლევს JSON  ფორმატის მონაცემების წასაკითხად და წერას Python ობიექტებში და პირიქით (მარტივად რომ ვთქვათ პითონს და Json-ს ვაკავშირებთ).
    

Task 002 

app = Flask(__name__) - აქ ვქმნით აპლიკაციას. app არის ცვლადის სახელი და აქ ვინახავთ შექმნილ აპლიკაციას. Flask არის კლასი, რომელიც მოდის Flask ბიბლიოთეკიდან.
ხოლო __name__ არის სპეციალური ცვლადი, რომელიც ნიშნავს ფაილის სახელს — ანუ ამ კონკრეტულ შემთხვევაში ეუბნება Flask-ს, რომ ეს ფაილია აპლიკაციის საწყისი წერტილი.

@app.route('/')  - app -ში ვინახავთ შემნილ აპლიკაციას და .route() მეთოდით ვეუბნებით საიტის მისამართს საიდან უნდა ჩაიტვირთოს. (მეთოდსაც გა გვინდა) თუ მარტო '/' -ს გადავცემთ მაშინ მთავარი გვერდიდან დაიწყებს.


@app.route('/')
def main_page():
    return render_template('sign_up.html')

ვქმნით ფუნქციას რომელმაც უნდა დააბრუნოს render_template() ფუნქციის დახმარებით sign_up.html გვერდი.


Task 003 
name = request.form.get('name')   - ასეთი რამ სადაც წერია, უკვე request მოდულის გამოყენებით form თეგიდან ვღებულობთ ინფორმაციას ატრიბუტი name -ის სახელის მიხედვით.

with open('all_user.json', 'r', encoding='utf-8') as f: - 
with - არის რაღაც რომელიც გამოიყენება ფაილის გახსნისთვის.
open() - არის ჩაშენებული ფუნქცია პითონში, რომელსაც გადაეცემა ჯერ ფაილის სახელი, რისი გახსნაც გვინდა. შემდეგ გადაეცემა ფაილის რეჟიმი. ანუ რა გვინდა რომ ვქნათ, წავიკითხოთ, დავწეროთ-ჩავამატოთ, დავაედითოთ...
    'r' — წაკითხვა (read)
    'w' — ჩაწერა (write), ფაილს წაშლის თუ არსებობს და ახალს შექმნის
    'a' — ჩაწერა (append), არსებული ტექსტის ბოლოს
encoding='utf-8' - არის პარამეტრი, რომელიც უთითებს, თუ რა ფორმატში არის ტექსტური ფაილი შენახული და როგორ უნდა ჩაიკითხოს. არსებობს ბევრი კოდი ყველაზე კარგი 'utf-8' არის.
    UTF-8: (უნივერსალური, ყველა სიმბოლოს მოიცავს, პოპულარული ინტერნეტში)
    ASCII: (მხოლოდ ინგლისური ასოები და სიმბოლოები, 0-127 ბაიტები)
    ISO-8859-1 (Latin-1): (ევროპული ენებისთვის)
    CP1252: (Windows-ის სტანდარტული კოდირება ევროპული ენებისთვის)
    CP1251: (კომპიუტერული კოდირება, ხშირად გამოიყენება რუსული და სხვა სლავური ენებისთვის)
    KOI8-R: (რუსული ტექსტისთვის)
    GB2312, Big5: (ჩინური ენებისთვის)


users = json.load(allUserFile)   - json მოდულს ვიყენებთ და მას აქვს ასეთი მეთოდი load() რომელიც ჯსონის ფაილში მყოფ ობიექტებს გარდაქმნის პითონის dict.
json.dump() ფუნქცია აკეთებს Python ობიექტის გადაკეთებას JSON ფორმატში და პირდაპირ ფაილში ჩაწერას.

except (FileNotFoundError, json.JSONDecodeError)   - FileNotFoundError - ფაილი როცა არ არის ნაპოვნი, json.JSONDecodeError ჯსონის ფაილი თუა დამახინჯებული


session['code'] = code
session['email'] = email
session['name'] = name
session['password'] = password
სესიონ ობიექტს ვიყენებთ რომელიც დავაიმპორტეთ. და მის შიგნით დროებით ვქმნით ცვლადებს (მაგალითად code) და მას მნიშნელობად ვანიჭებთ რაღაცას.



em = EmailMessage()    - ვქმით ობიექტს EmailMessage()-ის საშუალებით რომელიც დავაიმპორტეთ.
em['From'] = my_email  - ვუწერთ გამგზავნი ვინ არის
em['To'] = email       - მიმღებოს მისამართს
em['Subject'] = subject - სათაური
em.set_content(body)  - არის EmailMessage კლასის მეთოდი, რომელსაც ვიყენებთ ელ-ფოსტის მთავარი ტექსტური შინაარსის (body) დასაყენებლად.





with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp: # with -ს ვიყენებთ ისევ და უკვე ssl მოდულს ვიყენებთ მეილზე შესასვლელად. smtplib.SMTP_SSL smtplib მოდულში არსებული კლასია, რომელიც გამოიყენება დაშიფრული ssl კავშირის შესაქმნელად.
    smtp.login(my_email, my_password)
    smtp.send_message(em) 

()-ში იწერება ჯერ SMTP Server მეილის მისამართი. რომელიც იწყება smtp-ით, 
მეორე არგუმენტად იწერება პორტის ნომერი (პორტი არის "კარები", რომლითაც შენი აპლიკაცია ესაუბრება სერვერს. სხვადასხვა სერვისს აქვს თავისი პორტი)
return render_template('code.html', title='FINEbank.IO - Verification')


os.path.exists()  - os მოდულის მეთოდია რომელიც ამოწმებს ფაილი არსებობს თუ არა

fetch('/update_goal', {       - გადავცემთ მოქმედების მისამართს,
    method: 'POST',           - მეთოდი რომლითაც უნდა უპასუხოს
    headers: {                - გადავცემთ როგორ უნდა უპასუხოს და რას შეიცავს, ობიექტია, რომელიც გამოიყენება HTTP მოთხოვნაში დამატებითი ინფორმაციის გადასაცემად. ეს ინფორმაცია ეუბნება სერვერს, თუ როგორ უნდა წაიკითხოს და გაუმკლავდეს მოთხოვნას ან პასუხს.
        'Content-Type': 'application/json'  - სიტყვა სიტყვით ასე უნდა იყოს რაც იმას ნიშნავს რომ ფაილი ჯეისონ ფორმატშია
    },
    body: JSON.stringify({  -body — ეს არის ადგილი, სადაც ვწერთ იმ ინფორმაციას, რომლის გაგზავნაც გვინდა სერვერზე.
        target: targetMoney 
})})

if __name__ == '__main__': პირობა შემოგვაქვს და ვეკითხებით თუ __name__ არის მთავარი ფაილი
    app.run(debug=True)  - app (აპლიკაციას სადაც ვინახავთ) აქვს მეთოდი .run() რაც იმას ნიშნავს რომ კოდს გაუშვებს და debug=True ნიშნავს შეამოწმოს აქვს თუ არა ხარვეზები კოდს და დეტალურ ინფომრაციას გამოიტანს.